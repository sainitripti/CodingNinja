//Approach 1

#include<unordered_map>
int max(int arr[], int n) {
	/* Don't write main().
     * Don't read input, it is passed as function argument.
     * Return output and don't print it.
     * Taking input and printing output is handled automatically.
     */
  int max=0;
  for(int i=0;i<n;i++){
    unordered_map<int,int>counts;
    for(int j=i;j<n;j++){
      if(counts.count(arr[j])>0)
        counts[arr[j]]++;
      else
        counts[arr[j]]=1;
      if(counts[0]==counts[1]){
        int length=counts[0]*2;
        if(length>max)
          max=length;
      }
    }
  }
  return max;
}

//Approach 2
#include<unordered_map>
int max(int arr[], int n) {
	/* Don't write main().
     * Don't read input, it is passed as function argument.
     * Return output and don't print it.
     * Taking input and printing output is handled automatically.
     */

  unordered_map<int,int>counts;
  
  for(int j=0;j<n;j++){
    if(counts.count(arr[j])>0)
      counts[arr[j]]++;
    else
      counts[arr[j]]=1;
  }
  int start=0,end=n-1;
  while(start<end){
    if(counts[0]<counts[1]){
      if(arr[start]==1){
        start++;
        counts[1]--;
      }
      else if(arr[end]==1){
        end--;
        counts[1]--;
      }
      else{
        start++;
        counts[0]--;
      }
      if(counts[0]==counts[1])
        return 2*counts[0];
    }
    else{
      if(arr[start]==0){
        start++;
        counts[0]--;
      }
      else if(arr[end]==0){
        end--;
        counts[0]--;
      }
      else{
        start++;
        counts[1]--;
      }
      if(counts[0]==counts[1])
        return 2*counts[0];
    }
  }
  return 0;
}
